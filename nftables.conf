#!/usr/sbin/nft -f

# Сбрасываем все существующие правила для предотвращения конфликтов (сохраните текущие правила, если они вам нужны)
flush ruleset

# ИЗМЕНИТЕ ЭТО ЗНАЧЕНИЕ! Определяем инетрфейс для внешних подключений этого сервера
define interface_wan = eth0
# ИЗМЕНИТЕ ЭТО ЗНАЧЕНИЕ! Определяем внешний IPv4 этого сервера
define ipv4_wan = 127.0.0.1
# ИЗМЕНИТЕ ЭТО ЗНАЧЕНИЕ! Определяем внешний IPv6 этого сервера
# define ipv6_wan = ::1
# ИЗМЕНИТЕ ЭТО ЗНАЧЕНИЕ! Определяем список пиров с IPv4 виртуальной сети WireGuard
define wg0_peers_ipv4 = { 10.0.0.1, 10.0.0.2, 10.0.0.0/24 }
# ИЗМЕНИТЕ ЭТО ЗНАЧЕНИЕ! Определяем список пиров с IPv6 виртуальной сети WireGuard
define wg0_peers_ipv6 = { fdaa:abcd:dcba:aadf::1, fdaa:abcd:dcba:aadf::2, fdaa:abcd:dcba:aadf::0/64 }
# Определяем адреса Cloudflare, с которых разрешён web-трафик (актуализировано 25.12.2022)
#define cloudflare_ips = { 173.245.48.0/20, 103.21.244.0/22, 103.22.200.0/22, 103.31.4.0/22, 141.101.64.0/18, 108.162.192.0/18, 190.93.240.0/20, 188.114.96.0/20, 197.234.240.0/22, 198.41.128.0/17, 162.158.0.0/15, 104.16.0.0/13, 104.24.0.0/14, 172.64.0.0/13, 131.0.72.0/22 }

# Создаём таблицу маршрутизации под названием "global" для обработки IPv4 и IPv6
table inet global {

	# Создаём условную чёрную дыру для сбора временно заблокированных атакующих IP-адресов. Не актуально, если вы используете прокси от Cloudflare
	set blackhole {
		type ipv4_addr;
		flags dynamic, timeout;
		size 65536;
	}

	# Создаём правило переадресации портов из-под NAT, если у пира назначения в WireGuard нет выделенного IP и если в этом есть необходимость
#	map port_forwards_tcp_ipv4 {
#		type ipv4_addr . inet_service : ipv4_addr . inet_service
#		# Переадресуем порт 12345 с нашего внешнего IPv4 на порт 12345 по адресу 10.0.0.2/24 в виртуальной сети WireGuard
#		elements = { $ipv4_wan . 12345 : 10.0.0.2/24 . 12345 }
#	}

	# Создаём правило переадресации портов из-под NAT, если у пира назначения в WireGuard нет выделенного IP и если в этом есть необходимость
#	map port_forwards_tcp_ipv6 {
#		type ipv6_addr . inet_service : ipv6_addr . inet_service
#		# Переадресуем порт 12345 с нашего внешнего IPv6 на порт 12345 по адресу fdaa:abcd:dcba:aadf::2/64 в виртуальной сети WireGuard
#		elements = { $ipv6_wan . 12345 : fdaa:abcd:dcba:aadf::2/64 . 12345 }
#	}

	# Создаём цепь маршрутизации для внешних ВХОДЯЩИХ подключений
	chain input_wan {
		# Разрешаем web-трафик только с IP-адресов от Cloudflare. Не актуально, если вы не настроили прокси от Cloudflare
#		ip saddr $cloudflare_ips tcp dport { 80, 443 } accept comment "Accept HTTP, HTTPS"
		# Разрешаем web-трафик с контролем количества попыток подключений, превысившие количество подключений адреса попадают в чёрную дыру. Не актуально, если вы используете прокси от Cloudflare
		ct state new tcp dport { 80, 443 } meter flood size 128000 { ip saddr timeout 10s limit rate over 5/second } add @blackhole { ip saddr timeout 1m }
		ip saddr @blackhole drop

		# Разрешаем трафик для внешних подключений к WireGuard
		# Используйте первое правило, чтобы задать ограничение скорости для ВХОДЯЩЕГО трафика сервера
#		udp dport 51820 limit rate 5 mbytes/second accept
		udp dport 51820 accept
		
		# Разрешаем трафик для сервера Minecraft
		# Задаём ограничения для контроля количества попыток подключения. Подключения с адреса, превысившего количество возможных подключений, сбрасываются
		tcp dport 25565 limit rate over { 15/minute, 3/second } drop
		# Задаём ограничения для контроля скорости ВХОДЯЩЕГО подключения. Подключения с адреса, превысившего ограничение, сбрасываются
		tcp dport 25565 limit rate 1 mbytes/second drop
	}

	# Создаём цепь маршрутизации для виртуальной сети WireGuard
	chain input_vpn_wg0 {
		# Разрешаем трафик для внутренних подключений к WireGuard
		iifname "wg0" accept
	}

	# Создаём первичную цепь маршрутизации для внешних ВХОДЯЩИХ подключений
	chain input {
		# По-умолчанию сбрасываем весь трафик, не подходящий ни под одно из правил
		type filter hook input priority filter; policy drop;

		# Разрешаем трафик для успешно установленных соединений, сбрасываем недействительный
		ct state vmap { established : accept, related : accept, invalid : drop }

		# Сброс поддельного локального трафика из внешних подключений
		iif != lo ip daddr 127.0.0.1/8 drop
		iif != lo ip6 daddr ::1/128 drop
		
		# Сброс поддельного трафика из зарезервированных или приватных адресов из внешних подключений
		# БУДЬТЕ ОСТОРЖНЫ ПРИ АКТИВАЦИИ ЭТОГО ПРАВИЛА
		# iifname $interface_wan ip saddr { 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 } drop
		
		# Сброс подозрительного трафика из зарезервированного списка портов из внешних подключений
		# БУДЬТЕ ОСТОРЖНЫ ПРИ АКТИВАЦИИ ЭТОГО ПРАВИЛА
		# iifname $interface_wan tcp sport 0-1023 drop

		# Accepting ping (icmp-echo-request) for diagnostic purposes
		meta l4proto icmp icmp type echo-request limit rate over 5/second drop comment "No ping floods"
#		meta l4proto icmp icmp type { destination-unreachable, router-solicitation, router-advertisement, time-exceeded, parameter-problem } accept comment "Accept ICMP"

		# Allow IPv6 configuration packets
		meta l4proto ipv6-icmp icmpv6 type echo-request limit rate over 5/second drop comment "No ping floods"
#		meta l4proto ipv6-icmp icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem, mld-listener-query, mld-listener-report, mld-listener-reduction, nd-router-solicit, nd-router-advert, nd-neighbor-solicit, nd-neighbor-advert, ind-neighbor-solicit, ind-neighbor-advert, mld2-listener-report } accept comment "Accept ICMPv6"

		# Allow dnat (port forwarding)
#		ct status dnat accept

		# allow loopback traffic, anything else jump to chain for further evaluation
		iifname vmap { lo : accept, $interface_wan : jump input_wan, wg0 : jump input_vpn_wg0 }

		# the rest is dropped by the above policy
	}

	chain forward {
		type filter hook forward priority filter; policy drop;

		# Allow traffic from established and related packets, drop invalid
		ct state vmap { established : accept, related : accept, invalid : drop }
		# Allow port forwarding
#		ct status dnat accept

		# connections from the internal nets to the out nets are allowed
		iifname wg0 oifname wg0 ip daddr $wg0_peers ct state new accept
#		iifname wg1 oifname $interface_wan accept
		# the rest is dropped by the above policy
	}

	chain prerouting {
		type nat hook prerouting priority dstnat; policy accept;
#       dnat ip addr . port to ip daddr . tcp dport map @port_forwards_tcp_ipv4
#       dnat ip6 addr . port to ip6 daddr . tcp dport map @port_forwards_tcp_ipv6
	}

	chain postrouting {
		type nat hook postrouting priority srcnat; policy accept;
		# Hide IPs from local nets to the internet.
		# We are using SNAT because we have static IP and it wil work faster than MASQUERADE
#		iifname wg1 oifname $interface_wan snat ip to ipv4_wan
	}
}
